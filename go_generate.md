# go help generate  

```bash
usage: go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
```

既存ファイル内のディレクティブに記述されたコマンドを生成する。 これらのコマンドはどのようなプロセスでも実行できるが、Goソース・ファイルを作成または更新することが目的である。

`go generate` は、`go build` や `go test` などで自動的に実行されることはない。明示的に実行しなければならない。

`go generate` はファイルをスキャンしてディレクティブを探します、

```go
//go:generate command argument...
```

(注意：先頭の空白と `"//go "` 内の空白は使わないこと) ここで、`command` は実行されるジェネレーターで、ローカルで実行可能な実行ファイルに対応する。
シェル・パス（gofmt）、完全修飾パス（/usr/you/bin/mytool）、または以下に説明するコマンド・エイリアスのいずれかでなければならない。

`go generate` はファイルを解析しないので、コメントや複数行の文字列の中でディレクティブのように見える行はディレクティブとして扱われることに注意してください。

ディレクティブの引数は、スペースで区切られたトークンか二重引用符で囲まれた文字列で、ジェネレータが実行されるときに個々の引数として渡されます。

引用符で囲まれた文字列は `Go 構文` を使用し、実行前に評価されます。引用符で囲まれた文字列は、ジェネレーターへの1つの引数として現れる。

コードが生成されたことを人間やツールプログラムに伝えるために、生成されたソースには以下の正規表現（Go構文）にマッチする行がなければならない:

```regexp
^// Code generated .* DO NOT EDIT\.$
```

この行は、ファイル内の最初のコメント以外の空白でないテキストの前になければならない。

Go generateは、ジェネレーターの実行時にいくつかの変数を設定する:

- `$GOARCH`
  - 実行アーキテクチャ (arm, amd64, etc.)
- `$GOOS`
  - 実行オペレーティング・システム (linux, windows, etc.)
- `$GOFILE`
  - ファイルのベース名。
- `$GOLINE`
  - ソースファイル中のディレクティブの行番号。
- `$GOPACKAGE`
  - ディレクティブを含むファイルのパッケージ名。
- `$GOROOT`
  - ジェネレーターを起動した `go` コマンドの`GOROOT`ディレクトリで、Goツールチェインと標準ライブラリが含まれている。
- `$DOLLAR`
  - ドル記号。
- `$PATH`
  - 親プロセスの`$PATH`。`$GOROOT/bin`を先頭に置く。 これにより、`go` コマンドを実行するジェネレーターは、親の `go generate` コマンドと同じ `go` を使用するようになる。

変数の置換と引用符で囲まれた文字列の評価以外は、コマンドライン上で "globbing" のような特別な処理は行われない。

コマンドを実行する前の最後のステップとして、`$GOFILE`や`$HOME`のような英数字名の環境変数を呼び出すと、コマンドライン全体で展開される。
変数展開の構文は、すべてのOSで`$NAME`である。
評価の順序により、変数は引用符で囲まれた文字列内でも展開される。
変数 `NAME` が設定されていない場合、 `$NAME` は空文字列に展開される。

このような形式のディレクティブは,

```go
//go:generate -command xxx args...
```

このソース・ファイルの残りの部分においてのみ、文字列 `xxx` が引数で指定されたコマンドを表すことを指定する。
これはエイリアスを作成したり、マルチワード・ジェネレーターを処理するために使用できる。
例えば,

```go
//go:generate -command foo go tool foo
```

コマンド "foo" はジェネレーター "go tool foo" を表す。

コマンドラインで指定された順序で、1つずつパッケージを生成する。
コマンドラインに1つのディレクトリから `.go` ファイルがリストされている場合、それらは1つのパッケージとして扱われる。
パッケージ内では、generateはパッケージ内のソース・ファイルをファイル名順に1つずつ処理します。
ソース・ファイル内では、ジェネレータはファイル内に現れる順番に、1つずつ実行されます。
また、`go generate`ツールはビルドタグに "generate" を設定するので、`go generate`ではファイルを調べることができるが、ビルド時には無視される。

無効なコードを持つパッケージについては、有効なパッケージ節を持つソース・ファイルのみを処理する。

いずれかのジェネレーターがエラー終了ステータスを返した場合、"go generate" はそのパッケージの以降の処理をすべてスキップします。

ジェネレーターはパッケージのソース・ディレクトリで実行される。

Go generate は、2 つの特定のフラグを受け付けます:

- `-run=""`
  - 空でない場合は、元のソーステキスト (末尾の空白と最後の改行は除く) がすべてこの式にマッチするディレクティブを選択するための正規表現を指定します。

- `-skip=""`
  - 空でない場合は、元のテキスト (末尾の空白と最後の改行は除く) がこの正規表現にマッチするディレクティブを抑制するための正規表現を指定します。ディレクティブが -run 引数と -skip 引数の両方にマッチした場合、そのディレクティブはスキップされます。

`-v`、`-n`、`-x`を含む標準的なビルドフラグも受け付ける。
`-v` フラグは、処理されたパッケージとファイルの名前を表示する。
`-n` フラグは、実行されるコマンドを表示する。
`-x` フラグは、実行されたコマンドを表示する。

ビルドフラグの詳細については、`go help build` を参照のこと。

パッケージの指定については、 `go help packages` を参照のこと。
